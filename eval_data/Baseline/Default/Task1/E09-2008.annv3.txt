Citance Number: 1 | Reference Article: E09-2008.txt | Citing Article: N13-1140.txt | Citation Marker Offset: ['161'] | Citation Marker: Hulden, 2009 | Citation Offset: ['161'] | Citation Text: <S sid ="161" ssid = "4">Recently, open-source tools have been released: in this paper, we used Foma (Hulden, 2009) to develop the Russian guesser.</S> | Reference Offset: ['42'] | Reference Text: <S sid ="42" ssid = "10">10 } Here, instead of calling the fsm regex() function to construct the machine from a regular expressions, we could instead have accessed the beforementioned low-level routines and built the network entirely without regular expressions by combining low-level primitives, as follows, replacing line 5 in the above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(&quot;a&quot;)), fsm_kleene_plus( fsm_symbol(&quot;b&quot;))); The API is currently under active development and future functionality is likely to include conversion of networks to 8-bit letter transducers/automata for maximum speed in regular expression matching and transduction.</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 2 | Reference Article: E09-2008.txt | Citing Article: W11-2605.txt | Citation Marker Offset: ['73'] | Citation Marker: Hulden, 2009a | Citation Offset: ['73'] | Citation Text: <S sid ="73" ssid = "11">The rules that are learned are in the format of so-called phonological replacement rules (Beesley and Karttunen, 2002) which we have later converted into equivalent finite-state transducers using the freely available foma toolkit (Hulden, 2009a).</S> | Reference Offset: ['6'] | Reference Text: <S sid ="6" ssid = "6">The compiler allows users to specify finite-state automata and transducers incrementally in a similar fashion to AT&amp;T’s fsm (Mohri et al., 1997) and Lextools (Sproat, 2003), the Xerox/PARC finite- state toolkit (Beesley and Karttunen, 2003) and the SFST toolkit (Schmid, 2005).</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 3 | Reference Article: E09-2008.txt | Citing Article: W12-1003.txt | Citation Marker Offset: ['43'] | Citation Marker: Hulden, 2009 | Citation Offset: ['43'] | Citation Text: <S sid ="43" ssid = "15">The syllable counter is implemented using the foma software (Hulden, 2009), and the implementation (Hulden, 2006) can be found on the homepage of Figure 1: A verse written in the BAD web application.</S> | Reference Offset: ['42'] | Reference Text: <S sid ="42" ssid = "10">10 } Here, instead of calling the fsm regex() function to construct the machine from a regular expressions, we could instead have accessed the beforementioned low-level routines and built the network entirely without regular expressions by combining low-level primitives, as follows, replacing line 5 in the above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(&quot;a&quot;)), fsm_kleene_plus( fsm_symbol(&quot;b&quot;))); The API is currently under active development and future functionality is likely to include conversion of networks to 8-bit letter transducers/automata for maximum speed in regular expression matching and transduction.</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 4 | Reference Article: E09-2008.txt | Citing Article: W12-6202.txt | Citation Marker Offset: ['124'] | Citation Marker: 2009a | Citation Offset: ['124'] | Citation Text: <S sid ="124" ssid = "44">Since the question of transducer functionality is known to be decidable (Blattner and Head, 1977), and an efficient algorithm is given in Hulden (2009a), which is included in foma (with the command test functional) we can address this question by calculating the above for each constraint, if necessary, and then permute the violation markers until the above transducer is functional.</S> | Reference Offset: ['42'] | Reference Text: <S sid ="42" ssid = "10">10 } Here, instead of calling the fsm regex() function to construct the machine from a regular expressions, we could instead have accessed the beforementioned low-level routines and built the network entirely without regular expressions by combining low-level primitives, as follows, replacing line 5 in the above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(&quot;a&quot;)), fsm_kleene_plus( fsm_symbol(&quot;b&quot;))); The API is currently under active development and future functionality is likely to include conversion of networks to 8-bit letter transducers/automata for maximum speed in regular expression matching and transduction.</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 5 | Reference Article: E09-2008.txt | Citing Article: W12-6211.txt | Citation Marker Offset: ['49'] | Citation Marker: Hulden, 2009 | Citation Offset: ['49'] | Citation Text: <S sid ="49" ssid = "22">Foma (Hulden, 2009) is a freely available2 toolkit that allows to both build and parse FS automata and transducers.</S> | Reference Offset: ['6'] | Reference Text: <S sid ="6" ssid = "6">The compiler allows users to specify finite-state automata and transducers incrementally in a similar fashion to AT&amp;T’s fsm (Mohri et al., 1997) and Lextools (Sproat, 2003), the Xerox/PARC finite- state toolkit (Beesley and Karttunen, 2003) and the SFST toolkit (Schmid, 2005).</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 6 | Reference Article: E09-2008.txt | Citing Article: W12-6212.txt | Citation Marker Offset: ['22'] | Citation Marker: Hulden, 2009 | Citation Offset: ['22'] | Citation Text: <S sid ="22" ssid = "22">This verb chain transfer module is implemented as a series of ordered replacement rules (Beesley and Karttunen, 2003) using the foma finite-state toolkit (Hulden, 2009).</S> | Reference Offset: ['6'] | Reference Text: <S sid ="6" ssid = "6">The compiler allows users to specify finite-state automata and transducers incrementally in a similar fashion to AT&amp;T’s fsm (Mohri et al., 1997) and Lextools (Sproat, 2003), the Xerox/PARC finite- state toolkit (Beesley and Karttunen, 2003) and the SFST toolkit (Schmid, 2005).</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 7 | Reference Article: E09-2008.txt | Citing Article: W12-6212.txt | Citation Marker Offset: ['80'] | Citation Marker: Hulden, 2009 | Citation Offset: ['80'] | Citation Text: <S sid ="80" ssid = "43">In the work presented here, we have reimplemented and expanded the original rules written for XFST with the foma2 toolkit (Hulden, 2009).</S> | Reference Offset: ['27'] | Reference Text: <S sid ="27" ssid = "10">For instance, suppose we have defined an arbitrary regular language L, and want to further define a language that contains only one factor of L, we can do so by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply to substrings, and we attribute the usual meaning to ∈ and ∧, and a kind of concatenative meaning to the predicate S(t1, t2).</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 8 | Reference Article: E09-2008.txt | Citing Article: W12-6213.txt | Citation Marker Offset: ['77'] | Citation Marker: Hulden, 2009a | Citation Offset: ['77'] | Citation Text: <S sid ="77" ssid = "46">This can be then be used in spell checking applications, for example, by integrating the lexicon with weighted transduc ers reflecting frequency information and error models (Hulden, 2009a; Pirinen et al., 2010).</S> | Reference Offset: ['28'] | Reference Text: <S sid ="28" ssid = "11">Hence, in the above example, OneL defines the language where there exists a string x such that x is a member of the language L and there does not exist a string y, also in L, such that y would occur in a different position than x. This kind of logical specification of regular languages can be very useful for building some languages that would be quite cumbersome to express with other regular expression operators.</S> | Discourse Facet: BLANK | Annotator: Predictions

