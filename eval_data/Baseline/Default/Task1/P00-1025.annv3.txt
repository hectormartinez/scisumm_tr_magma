Citance Number: 1 | Reference Article: P00-1025 | Citing Article: J06-1004 | Citation Marker Offset: '104' | Citation Marker: Beesley and Karttunen,2000 | Citation Offset: '104' | Citation Text: <S sid ="104" ssid = "39">Beesley and Karttunen (2000) describe a technique, called compile-replace, for constructing FSTs, which involves reapplying the regular-expression compiler to its own output.</S> | Reference Offset: ['3'] | Reference Text: <S sid ="3" ssid = "3">We describe a new technique for constructing finite- state transducers that involves reapplying the regular-expression compiler to its own output.</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 2 | Reference Article: P00-1025 | Citing Article: P55-62_p00 | Citation Marker Offset: '52' | Citation Marker: 7.0 | Citation Offset: '52' | Citation Text: <S sid ="52" ssid = "52">Beesleyl7l presents a finite-state morphological analyzer for Arabic, which displays the root, pattern and prefixes/suffixes.</S> | Reference Offset: ['123'] | Reference Text: <S sid ="123" ssid = "50">This insight of Kataja and Koskenniemi was applied by Beesley in a large-scale morphological analyzer for Arabic, first using an implementation that simulated the intersection of stems in code at runtime (Beesley, 1989; Beesley et al., 1989; Beesley, 1990; Beesley, 1991), and ran rather slowly; and later, using Xerox finite-state technology (Beesley, 1996; Beesley, 1998a), a new implementation that intersected the stems at compile time and performed well at runtime.</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 3 | Reference Article: P00-1025 | Citing Article: P9852_p00 | Citation Marker Offset: '200','201' | Citation Marker: Beesley and Karttunen,2000 | Citation Offset: '200', '201' | Citation Text: <S sid ="200" ssid = "43">Thus, we employ the com pile-replace feature in xfst (Beesley &amp; Karttunen, 2000).</S>   <S sid ="201" ssid = "44">This feature allows the repetition of arbi trarily complex sublanguages by specifying the brackets &apos;&quot;&apos;[ &quot; and &quot;A 1 &quot; to mark the domain of re duplication.</S> | Reference Offset: ['8'] | Reference Text: <S sid ="8" ssid = "8">Finite-state morphology in the tradition of the Two-Level (Koskenniemi, 1983) and Xerox implementations (Karttunen, 1991; Karttunen, 1994; Beesley and Karttunen, 2000) has been very successful in implementing large-scale, robust and efficient morphological analyzergenerators for concatenative languages, includ ing the commercially important European languages and non-Indo-European examples like 1 I wish to thank Stuart Newton for this example.</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 5 | Reference Article: P00-1025 | Citing Article: PE2006_p00 | Citation Marker Offset: '104' | Citation Marker: Beesley and Karttunen,2000 | Citation Offset: '104' | Citation Text: <S sid ="104" ssid = "39">Beesley and Karttunen (2000) describe a technique, called compile-replace, for constructing FSTs, which involves reapplying the regular-expression compiler to its own output.</S> | Reference Offset: ['3'] | Reference Text: <S sid ="3" ssid = "3">We describe a new technique for constructing finite- state transducers that involves reapplying the regular-expression compiler to its own output.</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 6 | Reference Article: P00-1025 | Citing Article: Plex_p00 | Citation Marker Offset: '31' | Citation Marker: Beesley and Karttunen,2000 | Citation Offset: '31' | Citation Text: <S sid ="31" ssid = "31">Challenging non-concatenative morphological phenomena, such as circumfixion and root-and-pattern morphology, can be characterized by regular means (Beesley and Karttunen 2000, 2003).</S> | Reference Offset: ['8'] | Reference Text: <S sid ="8" ssid = "8">Finite-state morphology in the tradition of the Two-Level (Koskenniemi, 1983) and Xerox implementations (Karttunen, 1991; Karttunen, 1994; Beesley and Karttunen, 2000) has been very successful in implementing large-scale, robust and efficient morphological analyzergenerators for concatenative languages, includ ing the commercially important European languages and non-Indo-European examples like 1 I wish to thank Stuart Newton for this example.</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 7 | Reference Article: P00-1025 | Citing Article: Plex_p00 | Citation Marker Offset: '32' | Citation Marker: Beesley and Karttunen,2000 | Citation Offset: '32' | Citation Text: <S sid ="32" ssid = "32">Even total reduplication can be characterized without going outside the regular languages (Beesley and Karttunen 2000).</S> | Reference Offset: ['8'] | Reference Text: <S sid ="8" ssid = "8">Finite-state morphology in the tradition of the Two-Level (Koskenniemi, 1983) and Xerox implementations (Karttunen, 1991; Karttunen, 1994; Beesley and Karttunen, 2000) has been very successful in implementing large-scale, robust and efficient morphological analyzergenerators for concatenative languages, includ ing the commercially important European languages and non-Indo-European examples like 1 I wish to thank Stuart Newton for this example.</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 8 | Reference Article: P00-1025 | Citing Article: Pmorph_p00 | Citation Marker Offset: '67' | Citation Marker: Beesley and Karttunen | Citation Offset: '67' | Citation Text: <S sid ="67" ssid = "1">In this section we will show in detail how Realizational Morphology can be expressed in terms of the parc/xrce regular expression calculus as dened in Beesley and Karttunen [4].</S> | Reference Offset: ['29'] | Reference Text: <S sid ="29" ssid = "12">If the relation is finite-state, then it can be defined using the metalanguage of regular expressions; and, with a suitable compiler, the regular expression source code can be compiled into a finite-state transducer (fst), as shown in Figure 4, that implements the relation computationally.</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 10 | Reference Article: P00-1025 | Citing Article: Pstat_p00 | Citation Marker Offset: '86' | Citation Marker: Beesley and Karttunen,2000 | Citation Offset: '86' | Citation Text: <S sid ="86" ssid = "59">The application of the merge algorithm to the lower-side of the relation is performed by the COMPILER EPL ACE algorithm (Beesley and Karttunen, 2000),11 and the result is shown in Figure 7.</S> | Reference Offset: ['199'] | Reference Text: <S sid ="199" ssid = "126">Analyzer/Generator The current Arabic system has been described in some detail in previous publications (Beesley, 1996; Beesley, 1998a; Beesley, 1998b) and is available for testing on the Internet.7 The modification of the system to use the compile-replace algorithm has not changed the size or the behavior of the system in any way, but it has reduced the compilation time from hours to minutes.</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 11 | Reference Article: P00-1025 | Citing Article: W02-0503-parscit130908 | Citation Marker Offset: '17' | Citation Marker: Beesley and Karttunen,2000 | Citation Offset: '17' | Citation Text: <S sid ="17" ssid = "17">Beesley and Karttunen (2000) described a new technique for constructing finite-state transducers that involves reapplying a regular-expression compiler to its own output.</S> | Reference Offset: ['3'] | Reference Text: <S sid ="3" ssid = "3">We describe a new technique for constructing finite- state transducers that involves reapplying the regular-expression compiler to its own output.</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 12 | Reference Article: P00-1025 | Citing Article: W07-0802-parscit130908 | Citation Marker Offset: '134' | Citation Marker: Beesley and Karttunen,2000 | Citation Offset: '134' | Citation Text: <S sid ="134" ssid = "1">A large-scale implementation of the Arabic morphological system is the Xerox Arabic Morphologi cal Analyzer and Generator (Beesley and Karttunen,2000; Beesley, 2001).</S> | Reference Offset: ['8'] | Reference Text: <S sid ="8" ssid = "8">Finite-state morphology in the tradition of the Two-Level (Koskenniemi, 1983) and Xerox implementations (Karttunen, 1991; Karttunen, 1994; Beesley and Karttunen, 2000) has been very successful in implementing large-scale, robust and efficient morphological analyzergenerators for concatenative languages, includ ing the commercially important European languages and non-Indo-European examples like 1 I wish to thank Stuart Newton for this example.</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 13 | Reference Article: P00-1025 | Citing Article: W08-0703 | Citation Marker Offset: '15' | Citation Marker: Beesley and Karttunen,2000 | Citation Offset: '15' | Citation Text: <S sid ="15" ssid = "15">In the last decade, finite-state approaches to phonology (Gildea and Jurafsky, 1996; Beesley and Karttunen, 2000) have effectively brought theoretical linguistic work on rewrite rules into the computational realm.</S> | Reference Offset: ['8'] | Reference Text: <S sid ="8" ssid = "8">Finite-state morphology in the tradition of the Two-Level (Koskenniemi, 1983) and Xerox implementations (Karttunen, 1991; Karttunen, 1994; Beesley and Karttunen, 2000) has been very successful in implementing large-scale, robust and efficient morphological analyzergenerators for concatenative languages, includ ing the commercially important European languages and non-Indo-European examples like 1 I wish to thank Stuart Newton for this example.</S> | Discourse Facet: BLANK | Annotator: Predictions

Citance Number: 14 | Reference Article: P00-1025 | Citing Article: W09-0802 | Citation Marker Offset: '207' | Citation Marker: Beesley and Karttunen,2000 | Citation Offset: '207' | Citation Text: <S sid ="207" ssid = "74">The interdigitation is handled using a compile-replace process using the replace operator (Karttunen and Beesley, 2000) (Karttunen, 1995).</S> | Reference Offset: ['40'] | Reference Text: <S sid ="40" ssid = "23">The source descriptions may also be written in higher-level notations (e.g. lexc (Karttunen, 1993), twolc (Karttunen and Beesley, 1992) and Replace Rules (Karttunen, 1995; Karttunen, 1996; Kempe and Karttunen, 1996)) that are simply helpful short- hands for regular expressions and that compile, using their dedicated compilers, into finite-state networks.</S> | Discourse Facet: BLANK | Annotator: Predictions

